// Code generated by mockery v1.0.0. DO NOT EDIT.

package identity

import (
	database "github.com/artem-malko/auth-and-go/infrastructure/database"
	mock "github.com/stretchr/testify/mock"

	models "github.com/artem-malko/auth-and-go/models"

	uuid "github.com/google/uuid"
)

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

// CreateEmailIdentity provides a mock function with given fields: identity, executor
func (_m *MockRepository) CreateEmailIdentity(identity models.Identity, executor database.QueryExecutor) (*models.Identity, error) {
	ret := _m.Called(identity, executor)

	var r0 *models.Identity
	if rf, ok := ret.Get(0).(func(models.Identity, database.QueryExecutor) *models.Identity); ok {
		r0 = rf(identity, executor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(models.Identity, database.QueryExecutor) error); ok {
		r1 = rf(identity, executor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSocialIdentity provides a mock function with given fields: identity, executor
func (_m *MockRepository) CreateSocialIdentity(identity models.Identity, executor database.QueryExecutor) (*models.Identity, error) {
	ret := _m.Called(identity, executor)

	var r0 *models.Identity
	if rf, ok := ret.Get(0).(func(models.Identity, database.QueryExecutor) *models.Identity); ok {
		r0 = rf(identity, executor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(models.Identity, database.QueryExecutor) error); ok {
		r1 = rf(identity, executor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIdentitiesByAccountID provides a mock function with given fields: accountID, executor
func (_m *MockRepository) DeleteIdentitiesByAccountID(accountID uuid.UUID, executor database.QueryExecutor) error {
	ret := _m.Called(accountID, executor)

	var r0 error
	if rf, ok := ret.Get(0).(func(uuid.UUID, database.QueryExecutor) error); ok {
		r0 = rf(accountID, executor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteIdentitiesByIdentityIDs provides a mock function with given fields: identityIDs, executor
func (_m *MockRepository) DeleteIdentitiesByIdentityIDs(identityIDs []uuid.UUID, executor database.QueryExecutor) error {
	ret := _m.Called(identityIDs, executor)

	var r0 error
	if rf, ok := ret.Get(0).(func([]uuid.UUID, database.QueryExecutor) error); ok {
		r0 = rf(identityIDs, executor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetEmailIdentityByEmail provides a mock function with given fields: email, executor
func (_m *MockRepository) GetEmailIdentityByEmail(email string, executor database.QueryExecutor) (*models.Identity, error) {
	ret := _m.Called(email, executor)

	var r0 *models.Identity
	if rf, ok := ret.Get(0).(func(string, database.QueryExecutor) *models.Identity); ok {
		r0 = rf(email, executor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, database.QueryExecutor) error); ok {
		r1 = rf(email, executor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentitiesByAccountID provides a mock function with given fields: accountID, executor
func (_m *MockRepository) GetIdentitiesByAccountID(accountID uuid.UUID, executor database.QueryExecutor) ([]*models.Identity, error) {
	ret := _m.Called(accountID, executor)

	var r0 []*models.Identity
	if rf, ok := ret.Get(0).(func(uuid.UUID, database.QueryExecutor) []*models.Identity); ok {
		r0 = rf(accountID, executor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uuid.UUID, database.QueryExecutor) error); ok {
		r1 = rf(accountID, executor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentitiesByEmail provides a mock function with given fields: email, executor
func (_m *MockRepository) GetIdentitiesByEmail(email string, executor database.QueryExecutor) ([]*models.Identity, error) {
	ret := _m.Called(email, executor)

	var r0 []*models.Identity
	if rf, ok := ret.Get(0).(func(string, database.QueryExecutor) []*models.Identity); ok {
		r0 = rf(email, executor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, database.QueryExecutor) error); ok {
		r1 = rf(email, executor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityBySocialID provides a mock function with given fields: socialID, socialNetworkType, executor
func (_m *MockRepository) GetIdentityBySocialID(socialID string, socialNetworkType models.SocialNetworkType, executor database.QueryExecutor) (*models.Identity, error) {
	ret := _m.Called(socialID, socialNetworkType, executor)

	var r0 *models.Identity
	if rf, ok := ret.Get(0).(func(string, models.SocialNetworkType, database.QueryExecutor) *models.Identity); ok {
		r0 = rf(socialID, socialNetworkType, executor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, models.SocialNetworkType, database.QueryExecutor) error); ok {
		r1 = rf(socialID, socialNetworkType, executor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIdentityStatus provides a mock function with given fields: identityID, identityStatus, executor
func (_m *MockRepository) UpdateIdentityStatus(identityID uuid.UUID, identityStatus models.IdentityStatus, executor database.QueryExecutor) (*models.Identity, error) {
	ret := _m.Called(identityID, identityStatus, executor)

	var r0 *models.Identity
	if rf, ok := ret.Get(0).(func(uuid.UUID, models.IdentityStatus, database.QueryExecutor) *models.Identity); ok {
		r0 = rf(identityID, identityStatus, executor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uuid.UUID, models.IdentityStatus, database.QueryExecutor) error); ok {
		r1 = rf(identityID, identityStatus, executor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePasswordHash provides a mock function with given fields: accountID, passwordHash, executor
func (_m *MockRepository) UpdatePasswordHash(accountID uuid.UUID, passwordHash string, executor database.QueryExecutor) error {
	ret := _m.Called(accountID, passwordHash, executor)

	var r0 error
	if rf, ok := ret.Get(0).(func(uuid.UUID, string, database.QueryExecutor) error); ok {
		r0 = rf(accountID, passwordHash, executor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
